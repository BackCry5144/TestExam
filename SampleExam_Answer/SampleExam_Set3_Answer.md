**1. 정답: D**

* **해설:** Static Entity 생성 시 시스템이 자동으로 부여하는 속성은 `Id`, `Order`, `Is_Active`, `Label`의 4가지입니다. `Description`은 필요할 경우 개발자가 수동으로 추가해야 하는 속성입니다.

**2. 정답: D**

* **해설:** Role을 생성하면 시스템은 해당 권한을 확인하고 부여/취소하기 위한 `Check{Role}`, `Grant{Role}`, `Revoke{Role}` 액션을 자동으로 생성합니다. `Delete{Role}` 액션은 존재하지 않습니다.

**3. 정답: B**

* **해설:** `CommitTransaction`이 호출된 시점까지의 데이터베이스 변경 사항은 **확정 저장**됩니다. 그 이후에 발생하는 에러는 해당 지점 이후의 로직만 취소(롤백)시킵니다.

**4. 정답: B**

* **해설:** `List` 위젯은 여러 레코드를 보여주기 위한 도구이므로, 데이터 소스로 반드시 **Aggregate**나 **Data Action**의 결과물인 리스트 형태를 전달해야 합니다.

**5. 정답: A**

* **해설:** Reactive Web 아키텍처에서 Client Action이 Server Action을 호출하면 브라우저는 서버의 응답을 받을 때까지 해당 로직 라인에서 **대기**합니다.

**6. 정답: A**

* **해설:** Aggregate에서 엔티티를 조인하면 기본적으로 ID 관계에 의해 조인 조건이 생성되지만, **Joins 탭**에서 해당 조건을 클릭하여 사용자가 원하는 로직으로 수동 수정이 가능합니다.

**7. 정답: C**

* **해설:** 화면 로딩 시 외부 API에서 데이터를 가져와야 한다면, **Data Action**을 생성하고 `Fetch` 속성을 **At Start**로 설정하는 것이 가장 표준적이고 효율적입니다.

**8. 정답: B**

* **해설:** 특정 예외(Database Exception)에 대한 전용 핸들러가 없으면, 예외는 상위로 전파(Bubble up)되어 가장 포괄적인 **All Exceptions** 핸들러에서 처리됩니다.

**9. 정답: B**

* **해설:** **Ajax Submit**은 Traditional Web 방식의 유물입니다. Reactive Web은 기본적으로 모든 서버 통신이 비동기로 이루어지므로 버튼에 별도의 Ajax 설정을 할 필요가 없습니다.

**10. 정답: B**

* **해설:** **Preparation**은 서버 사이드 렌더링 방식인 Traditional Web에서만 사용되는 데이터 준비 단계입니다. Reactive Web은 화면 로딩과 동시에 비동기로 데이터를 가져오는 방식을 채택합니다.

**11. 정답: A**

* **해설:** 사용자가 클릭한 컬럼에 따라 정렬을 바꾸는 '동적 정렬'을 구현하려면, 정렬 기준이 담긴 Text 변수를 Aggregate의 **Dynamic Sort** 부분에 매핑해야 합니다.

**12. 정답: C**

* **해설:** `On After Fetch` 이벤트는 Aggregate가 서버로부터 데이터를 성공적으로 가져와 결과 리스트가 메모리에 준비된 **직후**에 실행됩니다. 데이터를 가공하거나 초기 변수값을 설정하기에 최적의 장소입니다.

**13. 정답: B**

* **해설:** Data Action의 결과물을 화면 위젯에 바인딩하여 보여주려면, 해당 액션이 화면 로드 시 자동으로 실행되도록 **Fetch** 속성이 **At Start**로 되어 있는지 확인해야 합니다.

**14. 정답: A**

* **해설:** `CurrDate()` 함수는 시스템의 오늘 날짜(시간 제외)를 반환하므로, 오늘 날짜와 생성일이 일치하는 주문들만 필터링하게 됩니다.

**15. 정답: B**

* **해설:** 루프(For Each) 내에서 개별 `Create` 액션을 반복하면 데이터베이스와의 통신(Round-trip)이 빈번해져 성능이 급격히 저하됩니다. 대량 데이터는 **SQL 위젯의 벌크 연산**이 훨씬 효율적입니다.

**16. 정답: A**

* **해설:** `GetUserId()` 내장 함수는 현재 로그인된 세션의 사용자 ID를 반환합니다. 로그인하지 않은 익명 사용자의 경우 `NullIdentifier()`를 반환합니다.

**17. 정답: A**

* **해설:** 흐름 제어 노드인 `Destination`을 만나면 현재 실행 중인 액션의 나머지 로직은 무시되고 즉시 지정된 화면으로 이동합니다.

**18. 정답: B**

* **해설:** Exception Handler는 예외 발생 시 흐름을 가로채서 처리하는 종착역과 같습니다. 핸들러 내부의 로직이 모두 실행되면 해당 액션의 흐름은 **종료(End)**됩니다.

**19. 정답: A**

* **해설:** Client Action 내부에서 `Run Server Action`을 배치하면, OutSystems는 내부적으로 이를 보안이 적용된 **REST API 호출**로 변환하여 처리합니다.

**20. 정답: C**

* **해설:** Site Property는 모든 세션이 공유하는 서버 변수입니다. 값을 변경하면 즉시 반영되지만, 서버는 캐시 갱신을 위해 애플리케이션 풀을 재시작할 수 있어 일시적인 성능 영향이 있을 수 있습니다.

**21. 정답: B**

* **해설:** 블록(Block)은 재사용 가능한 부품이므로, 부모로부터 필요한 데이터를 전달받기 위해 **Input Parameter**를 사용합니다.

**22. 정답: A**

* **해설:** 하위 요소(Block)가 상위 요소(Screen)를 직접 호출할 수는 없습니다. 따라서 **블록에서 이벤트를 발생(Trigger Event)**시키고, **부모 화면에서 해당 이벤트의 핸들러(Handler)**를 통해 로직을 실행해야 합니다.

**23. 정답: B**

* **해설:** Form 위젯의 `Save` 버튼 클릭 시 필수 항목이 누락되었다면, 서버에 데이터를 보내기 전 브라우저 수준에서 **Built-in Validation**을 수행하여 사용자에게 알립니다.

**24. 정답: B**

* **해설**: 페이지네이션(Pagination)에서 **StartIndex**는 현재 화면에 보여줄 리스트가 전체 데이터 중 몇 번째 인덱스부터 시작하는지(Offset)를 결정합니다. 예를 들어, 페이지당 10개씩 보여준다면 2페이지의 StartIndex는 10이 됩니다.

**25. 정답: B**

* **해설**: 화면 위에 별도의 작은 창을 띄워 사용자에게 정보를 보여주거나 입력을 받는 위젯은 **Popup**입니다. OutSystems UI에서 제공하는 패턴으로, 특정 조건이나 버튼 클릭 시 `showPopup` 액션 등을 통해 제어합니다.

**26. 정답: A**

* **해설**: Table 위젯의 각 컬럼에는 **Column Breakpoint** 속성이 있습니다. 이를 통해 특정 기기(예: Phone)에서 해당 컬럼을 자동으로 숨기거나 표시할지 결정하여 반응형 UI를 구현합니다.

**27. 정답: C**

* **해설**: Upload 위젯을 통해 선택된 파일의 바이너리(실제 데이터)는 위젯과 연결된 **Content** 속성에 저장됩니다. 파일명은 `Filename`, 파일 형식은 `Type` 속성에서 확인할 수 있습니다.

**28. 정답: B**

* **해설**: 사용자에게 처리 결과(성공, 에러, 경고 등)를 화면 상단에 잠시 띄워주는 시스템 액션은 **Feedback Message**입니다. 실무에서 가장 빈번하게 사용되는 알림 방식입니다.

**29. 정답: C**

* **해설**: Container 자체는 기본적으로 클릭 이벤트를 가지지 않지만, **Events** 탭에서 `On Click` 핸들러를 설정하거나 Container를 **Link** 위젯으로 감싸면 카드 전체를 클릭 가능하게 만들 수 있습니다.

**30. 정답: B**

* **해설:** `Escape Content` 속성을 **No**로 설정하면 HTML 태그를 텍스트로 보지 않고 코드로 해석하여 렌더링합니다. 단, 사용자 입력값을 직접 노출할 경우 보안 위협(XSS)이 있으므로 주의해야 합니다.

**31. 정답: A**

* **해설:** **Service Module**은 오직 비즈니스 로직과 데이터 서비스만을 제공하기 위해 설계되었으므로, **UI(Screen) 요소를 포함할 수 없습니다.**

**32. 정답: B**

* **해설:** **Side Reference**는 같은 레이어에 있는 모듈끼리 참조하는 것을 말합니다. (예: End-User 모듈 A가 End-User 모듈 B를 참조). 이는 아키텍처 위반은 아니지만 순환 참조 위험이 있어 주의가 필요합니다.

**33. 정답: B**

* **해설:** Server Action을 표현식(Expression)에서 함수처럼 쓰려면(`Is Function = Yes`), 결과를 반환할 **Output Parameter가 반드시 정확히 1개**여야 합니다.

**34. 정답: B**

* **해설**: **User Provider**를 `Current eSpace`로 설정하면, 해당 모듈은 다른 모듈과 사용자 정보를 공유하지 않는 독립적인 사용자 환경을 가집니다. 주로 멀티테넌시(Multi-tenancy) 환경이나 완전히 분리된 보안이 필요한 모듈에서 사용합니다.

**35. 정답: B**

* **해설**: `CheckRegisteredRole` 함수는 해당 사용자가 시스템에 **로그인한 상태**인지를 확인합니다. OutSystems에서 모든 로그인 사용자는 기본적으로 `Registered` 역할을 부여받기 때문입니다.

**36. 정답: A**

* **해설**: 다른 모듈의 **Server Action**을 참조하면 **Strong Dependency**가 발생합니다. 반면 **Service Action**을 참조하면 **Weak Dependency**가 발생하여, 로직 수정 시 참조 모듈을 매번 다시 배포하지 않아도 됩니다.

**37. 정답: C**

* **해설:** **Strong Dependency**(Server Action 등) 관계에서 Producer의 로직이 변경되었다면, Consumer 모듈을 반드시 **다시 배포(Republish)**해야만 변경된 로직 바이너리가 적용됩니다.

**38. 정답: B**

* **해설:** 동일한 값(가격)을 가진 레코드들의 정렬 순서가 매번 바뀌는 것을 막으려면, 고유한 값(예: Id, 등록일)을 **2차 정렬 조건**으로 추가하여 결과 순서를 확정(Deterministic)시켜야 합니다.

**39. 정답: C**

* **해설:** Switch 문에서 정의한 특정 조건들 외에 나머지 모든 경우를 한꺼번에 처리하려면 **Otherwise (Default)** 분기에 에러 처리 로직을 연결하면 됩니다.

**40. 정답: C**

* **해설:** 데이터베이스 속성 길이(50)보다 긴 값(100)을 강제로 저장하려 하면 데이터베이스 레벨에서 **데이터 잘림 예외(Database Exception)**가 발생합니다.

**41. 정답: B**

* **해설:** OutSystems에서 JavaScript로 특정 위젯을 조작하려면, 해당 위젯의 **Name 속성**이 반드시 지정되어 있어야 런타임에 고유한 HTML ID가 생성됩니다.

**42. 정답: B**

* **해설:** Integer 타입 변수에 텍스트("abc")를 입력하면 OutSystems의 내장 유효성 검사기가 이를 감지하여 해당 위젯의 **Valid 속성을 False**로 변경합니다.

**43. 정답: B**

* **해설:** 하위 모듈(Core)의 구조가 바뀌었는데 상위 모듈(End-User)이 이를 반영(Refresh Reference)하지 않은 채 배포를 시도하면 **Incompatible Producer** 에러가 발생합니다.

**44. 정답: B**

* **해설:** JSON 문자열은 복잡한 구조를 가지므로, 이를 OutSystems 데이터로 변환할 때는 그 구조와 일치하는 **Structure** (또는 List of Structure) 타입이 필요합니다.

**45. 정답: B**

* **해설:** OutSystems는 Aggregate에서 화면이나 로직에 실제로 바인딩되지 않은 컬럼을 감지하여 SQL 쿼리 시 자동으로 제외하는 **조회 최적화**를 수행합니다.

**46. 정답: B**

* **해설:** SQL 위젯에서 `Expand Inline` 파라미터를 사용하여 쿼리를 동적으로 생성할 때, 보안을 위해 반드시 해당 파라미터를 **EncodeSql()** 함수로 감싸야 합니다.

**47. 정답: B**

* **해설:** 애플리케이션의 공통 레이아웃(헤더, 푸터 포함)은 보통 **Common UI Flow** 안에 블록 형태로 정의되어 있으며, 테마(Theme)와 연결되어 관리됩니다.

**48. 정답: C**

* **해설:** `CreateOrUpdate...`는 서버와 통신하여 데이터베이스를 수정하는 **Server/Entity Action**입니다. 클라이언트 내에서 리스트 데이터를 조작하는 액션은 `ListAppend`, `ListRemove` 등입니다.

**49. 정답: B**

* **해설:** Reactive Web에서 뒤로 가기를 하면 브라우저 메모리에 유지된 상태를 보여주기도 하므로, **On Initialize**가 항상 다시 실행되지는 않습니다. 확실한 갱신이 필요하면 `OnReady` 등을 고려해야 합니다.

**50. 정답: B**

* **해설:** OutSystems 자격증 시험은 단순히 이론만 묻는 것이 아니라, "특정 비즈니스 시나리오에서 어떤 기능이 가장 적합한가?"를 묻는 문제가 대부분입니다. 따라서 단순히 정답을 외우기보다는, 강사 Gem과 함께 공부한 **개념(Lifecycle, Architecture, Security 등)**을 본인의 **실무 경험(MES, 공장 관리 등)**과 연결하여 논리적으로 판단하는 것이 합격의 가장 큰 비결입니다.